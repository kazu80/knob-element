<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../polymer/lib/mixins/gesture-event-listeners.html">

<dom-module id="knob-element">
    <template>
        <style>
            :host {
                display : block;
            }

            .wrapper {
                position: relative;
            }

            .debug__wrapper {
                position: relative;
                /* display: flex; */
                justify-content: space-around;
                margin-bottom: 20px;
                display: none;
            }

            @media (max-width : 767px) {
                .wrapper .debug__wrapper {
                    display        : flex;
                    flex-direction : column;
                    margin-bottom  : 20px;
                }
            }

            .wrapper .box__wrapper {
                position   : relative;
                /* padding    : 150px; */
                transition : transform 200ms;
            }

            .wrapper .box__wrapper .box {
                position          : relative;
                font-size         : 0;
                background-size   : contain;
                background-repeat : no-repeat;
                transition        : transform 200ms;
                user-select       : none;
            }

            .wrapper .box__wrapper .box .background-image {
                width       : 100%;
                user-select : none;
                visibility  : hidden;
            }

            .target-frame {
                position      : absolute;
                top           : -20px;
                left          : 50%;
                transform     : translateX(-50%);
                width         : 70px;
                height        : 90px;
                border        : 3px solid #dd1111;
                border-radius : 8px;
                z-index       : 100;
            }
        </style>

        <div class="debug__wrapper">
            <div class="x">x : [[x]]</div>
            <div class="y">y : [[y]]</div>
            <div class="y">degree : <input type="text" size="4" value="{{degree::input}}" /></div>
        </div>

        <div class="wrapper">
            <!-- <div class="target-frame"></div> -->
            <div id="frame" class="box__wrapper">
                <div id="box" class="box" on-track="handleTrack">
                    <img id="background" class="background-image">
                    <slot></slot>
                </div>
            </div>
        </div>

    </template>

    <script>
        class KnobConstant {
            static get ELEMENT_ICON() {
                return 'div';
            }

            static get ICON_CSS_CLASS_NAME() {
                return 'item';
            }

            static get DIRECTION_SWIPE() {
                return 'left';
            }
        }

        /**
         * `knob-element`
         * ui of like knob
         *
         * @customElement
         * @polymer
         * @demo demo/index.html
         */
        class KnobElement extends Polymer.GestureEventListeners(Polymer.Element) {

            static get is () { return 'knob-element'; }

            static get properties () {
                return {
                    degree           : {
                        type: Number,
                        value: 0,
                        observer: '_changeDegree',
                    },
                    selected         : {
                        type: Number,
                        observer: '_changeSelected',
                    },
                    distance         : {
                        type: Number,
                    },
                    knobBackgroundImage: {
                        type: String,
                        value: '',
                        observer: '_changeBackgroundImage',
                    },
                    menuCount        : {
                        type : Number,
                        value: 6,
                    },
                    menuBorder       : {
                        type: Number,
                        value: 3,
                    },
                    menuStartPosition: {
                        type: Number,
                        value: 90,
                    },
                    knobWidth : {
                        type: Number,
                        value: 0,
                    },
                    knobHeight : {
                        type: Number,
                        value: 0,
                    }
                };
            }

            ready () {
                super.ready ();

                this.menuElements =
                    this.shadowRoot
                        .querySelector('slot')
                        .assignedNodes({flatten: true})
                        .filter (n => n.nodeName === 'KNOB-ITEM');

                this.width  = this.$.box.clientWidth ? this.$.box.clientWidth : this.knobWidth;
                this.height = this.$.box.clientWidth ? this.$.box.clientWidth : this.knobHeight;

                this.rect   = this.$.box.getBoundingClientRect();
                this.start  = 0;
                this.end    = 0;
                this.divide = 360 / this.menuCount;
                this.selected = 1;
                this.position_visible = this.menuBorder;
                this.position_disapper = this.menuBorder - 1;

                this.smooth = 0;
                this.smoothUp = 0.5;

                this.setMenus();
            }

            setMenus () {
                const [base_x, base_y] = KnobElement.getBasePointXY(this.width, this.height);

                if (base_x === 0 || base_y === 0) {
                    console.warn('Not find base point!');
                }

                for (let i = 0; i < this.menuElements.length; i++) {
                    const menu = this.menuElements[i];

                    // set angle of parts
                    let angle = this.divide * i;

                    // distance
                    if (!this.distance) {
                        this.distance = base_y * 0.7;
                    }

                    // update start position
                    angle = angle - this.menuStartPosition;
                    const x2 = base_x + this.distance * Math.cos (angle * (Math.PI / 180));
                    const y2 = base_y + this.distance * Math.sin (angle * (Math.PI / 180));

                    menu.setAttribute('item-top', y2);
                    menu.setAttribute('item-left', x2);

                    // update menu icon size
                    menu.setAttribute('item-width', `${this.distance * 0.4}px`);
                    menu.setAttribute('item-height', `${this.distance * 0.4}px`);

                    // set visible
                    if (i < this.position_visible) {
                        menu.setAttribute('item-display', 'block');
                    } else {
                        menu.setAttribute('item-display', 'none');
                    }
                }
            }

            static getBasePointXY (width, height) {
                return [width / 2, height / 2];
            }

            handleTrack (e) {
                switch(e.detail.state) {
                    case 'start':
                        this.start = this.setRotate(e);
                        this.$.box.style.willChange = 'transform';
                        this.$.frame.style.willChange = 'transform';

                        for (let i = 0; i < this.menuElements.length; i++) {
                            const menu = this.menuElements[i];
                            menu.setAttribute ('item-will-change', 'auto');
                        }

                        //
                        this.$.frame.style.transform = 'scale(0.98)';

                        //
                        this.dispatchEvent (new CustomEvent ('touch-start'));

                        break;
                    case 'track':
                        this.end = this.setRotate (e);
                        this.degree = KnobElement.filterDegree (
                            this.start,
                            this.end,
                            this.degree,
                            100,
                            this.divide * this.menuElements.length,
                            0,
                            this.smooth
                        );
                        this.start = this.end;

                        //
                        this.smooth += this.smoothUp;

                        //
                        this.$.frame.style.transform = 'scale(0.98)';

                        break;
                    case 'end':
                        //
                        this.smooth = 0;

                        //
                        this.$.frame.style.transform = 'scale(1)';

                        //
                        this.$.box.style.willChange = 'inherit';
                        this.$.frame.style.willChange = 'inherit';

                        for (let i = 0; i < this.menuElements.length; i++) {
                            const menu = this.menuElements[i];
                            menu.setAttribute('item-will-change', 'inherit');
                        }

                        // Out of range
                        if (this.degree < 0) this.degree = 0;

                        // Max of range
                        if (this.degree > this.divide * (this.menuElements.length - 1)) this.degree = this.divide * (this.menuElements.length - 1);

                        // correction
                        const half      = this.divide / 2;
                        const remainder = this.degree % this.divide;
                        if (remainder > half) {
                            this.degree += half - (remainder - half);
                        } else {
                            this.degree -= remainder;
                        }

                        // set past degree
                        this.start = this.degree;

                        // set selected
                        this.selected = this.Degree2Selected();

                        //
                        this.dispatchEvent (new CustomEvent ('touch-end'));

                        break;
                }
            }

            Degree2Selected() {
                return (this.degree / this.divide) + 1;
            }

            static filterDegree (start, end, total, filter, max, min, smooth) {
                //
                let move = end - start;

                // direction of swipe
                if (KnobConstant.DIRECTION_SWIPE === 'left') {
                    move *= -1;
                }

                // limiter
                if (Math.abs (move) < filter) {

                    // smoother
                    if (Math.abs (move) > 1) {
                        move = this.smoother (move, smooth);
                    }

                    //
                    total = Number (total) + move;

                    // bar
                    total = this.bar (total, max, min);
                }

                return Number (total);
            }

            _changeBackgroundImage(val) {
                this.$.box.style.backgroundImage = `url(${val})`;
                this.$.background.setAttribute('src', val);
            }

            _changeDegree(val, old) {
                // direction of box rotate
                if (KnobConstant.DIRECTION_SWIPE === 'left') {
                    val = val * -1;
                }
                this.$.box.style.transform = `rotate(${val}deg)`;

                // CSS
                if (this.menuElements) {
                    if (KnobConstant.DIRECTION_SWIPE === 'left') {
                        val = val * -1;
                    }

                    //
                    const selected = val / this.divide;
                    for (let i = 0; i < this.menuElements.length; i++) {
                        const menu = this.menuElements[i];

                        //
                        if ((i - 0.2) < selected && (i + 0.2) > selected) {
                            menu.setAttribute ('item-is-selected', true);
                        } else {
                            menu.setAttribute ('item-is-selected', false);
                        }

                        //
                        menu.setAttribute('item-transform', `rotate(${val}deg) translate(-50%, -50%)`);

                        let display = 'none';
                        if ((i * this.divide * -1) + val >= this.position_disapper * this.divide * -1 &&
                            (i * this.divide * -1) + val <= this.position_disapper * this.divide) {
                            display = 'block';
                        }

                        if (menu.style.display !== display) {
                            menu.setAttribute('item-display', display);
                        }
                    }
                }
            }

            _changeSelected(val, old) {
                if (val !== old) {
                    this.dispatchEvent (new CustomEvent ('changed', {detail: {selected: this.selected}}));
                }

                for (let i = 0; i < this.menuElements.length; i++) {
                    const menu = this.menuElements[i];
                    menu.setAttribute('item-is-selected', false);
                    if (val === (i + 1)) {
                        menu.setAttribute('item-is-selected', true);
                    }
                }
            }

            static smoother (move, smooth) {
                if (move < 0) {
                    move += (smooth * -1);
                } else {
                    move += smooth;
                }

                return move;
            }

            static bar (val, max, min) {
                if (val < min) {
                    val *= 0.95;
                }
                if (val > max) {
                    val *= 0.95;
                }
                return val;
            }

            setRotate (e) {
                this.x = e.detail.x;
                this.y = e.detail.y;

                const [base_x, base_y] = KnobElement.getBasePointXY(this.width, this.height);
                let degree = KnobElement.getRadian (
                    this.rect.x + base_x,
                    this.rect.y + base_y,
                    this.x,
                    this.y
                ) * 180 / Math.PI;

                degree = Math.round(degree);

                return degree;
            }

            static getRadian (x1, y1, x2, y2) {
                return Math.atan2 (y2 - y1, x2 - x1);
            }
        }

        window.customElements.define (KnobElement.is, KnobElement);
    </script>
</dom-module>
